# System Overview 

The GamutRF system is a software stack that runs on low-cost consumer hardware. To simplify deployment and dependency management GamutRF relies on a series of Docker containers to provide an array of functionalities. Docker is a containerization technology that allows developers to isolate computing environments while only incurring minimal overhead when compared to virtual machines. 

![](imgs/gamutrf-system-software.png)
*Software system of GamutRF*

For GamutRF, each of these containers provide a specific service required for the collection system to operate. The services are generally a combination of python and C++ software developed by IQT Labs which heavily interfaces with GNU Radio (GR). The containers are distributed across different machines, depending on the requirements of a given deployment. For example, multiple worker nodes for RSSI calculation or signal recording, or multiple scanner nodes. There is always at least one orchestration node, which may also be a scanner node. 

## GamutRF Orchestration  

One of the most important features of GamutRF is its ability to detect energy and task sensors for recording. This is generally referred to as orchestration and is key to optimizing the utilization of constrained resources as in this use case of spectral sensing.  Since the sensor cannot be always consuming the entire spectrum, it must be able to rapidly scan, detect, and re-tune other sensors to record on bands and signals of interest. Successful orchestration requires the ability to perform fast and reliable scans on the spectrum to be observed. The faster this can be done, the better the spectrum can be accurately characterized.  

GamutRF achieves optimal scanning by minimizing the time needed for the radio to re-tune to a different band. This varies between radios and will determine how quickly a chunk of spectrum can be scanned. There are other factors such as instantaneous bandwidth (IBW), the maximum bandwidth a radio can see at one time, which determines the size of each re-tune step.  The bigger the IBW, the faster a radio can scan since it requires fewer steps to traverse the spectrum. High IBW combined with fast re-tune time is optimal for fast scanning.  

While scanning, after each re-tune of the radio, the GamutRF orchestrator will report any energy above a user-specified threshold of the current band it is in, then it will re-tune to the next band and repeat the process.  GamutRF can be configured to task another dedicated radio, called a worker, to collect if it detects energy or a certain signal in any of the bands it is scanning. This form of tasking is often referred to as tip and cue. After a “tip” has been generated by the energy detector, a “cue” is generated to task a dedicated sensor to get a better view of the signal in question.


![](imgs/gamutrf-orchestration.png)
*Tip and Cue Example of Orchestrator and Workers*

## Scanner Theory 

Efficient scanning is key to achieving our goal of sensing and identifying signals across a wide band of RF spectrum in the fastest possible time. The heart of the GamutRF system is the scanner which is based on the open-source GNU Radio SDR framework (see section on GNU Radio). The scanner is a GNU radio flowgraph containing several blocks that sweep across the spectrum at a configurable rate, while also storing the raw I/Q sample data for analysis and producing a spectrogram. The scanner also performs peak detection in which the center frequency, bandwidth and magnitude of energy exceeding a certain threshold is noted.    

Over the course of the project GamutRF’s scanner implementation was improved to enable it to scan more quickly. The first implementation of the scanner used host-based tuning in which the computer running the scanner sent commands to the SDR at fixed time intervals to achieve the sweep. This approach proved not to work well because tuning commands could not be issued at a consistent rate resulting in a variable sweep duration.  

The current GamutRF implementation now uses sample counting. When a pre-determined number of samples have been received by the SDR, GamutRF sends a tuning command to move to a new frequency while continuing to process samples. Samples arrive at the SDR at a fixed rate which eliminates need for a host-based timer and results in more consistent scan times. This technique was a significant improvement to data quality and scan stability. 

In addition to the SDR retune/command function, the other core component of the scanner is Fast Fourier Transform (FFT) processing. The FFT is used to generate spectrograms and spectral plots of the energy in the scan across frequency. Computation of the FFT is CPU intensive and can slow the system down. We were able to improve scanning performance by offloading FFT calculations from the CPU to a GPU using VkFFT1.  VkFFT is a Fast Fourier Transform library optimized for GPUs and supports several platforms including the Raspberry Pi-4 and Intel NUC computers.    

Our GNU radio design also enabled us to use the same scanner implementation on a separate platform, the Deepwave AIR-T. 

## System Components 

GamutRF has several components and services that are required for successful operation. The key components and services are described below. These are grouped into hardware and software components. 

### GamutRF Hardware 

GamutRF supports a variety of different hardware and radios ranging from inexpensive to moderately priced. Two of these systems are examples of different hardware price-points and are discussed next. 

#### Ettus B200mini/Raspberry Pi-4  

The “Pi Rig” is a version of the GamutRF platform built around commodity single board computers and commercial SDRs and is the least expensive of the options tested. The use of all consumer grade components keeps the project accessible. This compute platform paired with the Ettus B200 mini are a capable collection platform providing 20Msps across the 300MHz to 6GHz frequency spectrum. 

![](imgs/gamutrf-pi-rig.png)
*Raspberry Pi based GamutRF System*

The following COTS equipment is used to build the Pi Rig: 
- 3x Raspberry Pi 4 
- 3x Ettus B200mini 
- 1x POE ethernet switch 
- 1x Adafruit Ultimate GPS Board 
- 1x Adafruit Compass Board 

As described above, a Raspberry Pi node can be deployed as either an orchestrator/scanner or as a worker. Our standard build includes one orchestrator node and two worker nodes. More workers could be added as needed.  

While the Pi Rig is a capable demonstration unit, system performance is limited by the compute power available in such a small form factor. The data velocity in the RF space is extremely high and often reaching the limit of what the Pi is capable of handling. In our testing we have identified optimization to maximize the performance achievable by the Pi 4. This bottleneck is caused by frequency of accessing the USB controller to receive I/Q data and the FFT transform from time to frequency space. FFT is a computationally expensive task which has been offloaded to the onboard GPU using the VkFFT framework. This allows the CPU to focus on compression and disk I/O to avoid dropping data frames.  While performance is limited, the Pi system is still a performant tool when used with precision. We believe the Pi form factor is best used for narrow band scanning or in non-linear scan mode focusing only on frequency bands of interest. Because the cost of the platform is less than $5,000, it is a competitive target for orchestrator – worker workflows. 

#### AIR-T 

The Deepwave Artificial Intelligence Radio Transceiver (AIR-T)2 contains SDRs integrated with processing and deep learning inference hardware. The AIR-T also incorporates a graphics processing unit (GPU) to enable real-time wideband digital signal processing (DSP) algorithms to be executed in software. The AIR-T utilizes direct memory access (DMA) for extremely fast and efficient data transfers. These features combined with the large instantaneous bandwidth of the radio make it one of the higher performing systems for RF based machine learning applications.  

The AIR-T performed well in our use-cases and has a good application programming interface (API) for integration into custom software. The disadvantage of the AIR-T is that it is highly dependent on the NVidia GPU, in this case the Jetson TX2. This can be problematic for lifecycle support as this GPU relies on the Ubuntu 18.04 operating system, which has been deprecated as of April 2023. While this currently does not present major issues preventing the use of this system, this may not necessarily be the case in the future as this operating system ages and loses community support. Unfortunately, the AIR-T is not able to be upgraded with newer hardware.

### GamutRF Software 

GamutRF uses several applications and services to perform the various tasks associated with spectral awareness and geolocalization. The key applications and services are described below. 

- gamutrf-scan: Interfaces with SDR hardware to scan and dynamically retune. 
- gamutrf-sigfinder: Uses peak detection to find signals of interests, tasks workers. 
- gamutrf-waterfall: ingests FFT values, creates GUI to visualize data. 
- Compass: Interfaces with the compass hardware to make heading accessible to api. 
- gpsd: systemd process to provide endpoint for accessing GPS information. 
- API: container executed by a worker, receives tasking via sigfinder or manually, listens to narrow spectrum, publishes RSSI and heading info to MQTT. 
- Birdseye: signal localization service, ingests RSSI and heading from worker. 
- ZMQ: High-speed message broker, used to pass IQ / FFT data/metadata to services. 
- MQTT: Low-speed message broker for passing RSSI, GPS, and heading to Birdseye. 

The generic route for data during operation starts with the gamutrf-scan container reading I/Q data directly from the SDR. This I/Q is then processed into FFT values by CPU or GPU. The FFT values are passed to the ZMQ broker and optionally the I/Q is stored on the local file system. ZMQ then passes the FFT data to both sigfinder and the waterfall (GUI). The GUI simply visualizes spectrum, while sigfinder identifies signals of interest which should be further investigated.  

Sigfinder can task the api container which is running on a worker node to investigate a signal. The worker tunes to listen to the tasked frequency and either calculates the associated RSSI or makes a recording of the signal. In RSSI mode, the worker interrogates the gpsd service and compass container running on the orchestrator to get position and heading, then publishes location, heading, and RSSI to the MQTT broker to be consumed by Birdseye. Birdseye then uses this information to geolocate the target signal. 

Orchestrator.yml and worker.yml are the main control points for docker-compose to start the GamutRF system. These scripts spin up the iqtlabs/gamutrf Docker container and run the appropriate gamutrf-<cmd> python command. These files should be modified for the specific orchestrator and worker combination. Some common parameters for the gamut-scan and gamutrf-sigfinder are in the GamutRF [operation guide](./4-OPERATION.md).md. The repository also provides a few tools such as freespacer, compress_dirs, etc that can be used for post processing of data. These tools are included in the GamutRF python module so it is suggested to use them via iqtlabs/gamutrf docker container. 

## Graphical User Interface 

While not needed for running, the GUI offers users an intuitive means of visualizing and comprehending the collected data. The process ingests FFT samples being streamed from a ZeroMQ (ZMQ) broker where sampled values are collated and plotted through a Python Matplotlib script. This plot showcases both the immediate spectral content of the received signals and frequency-time spectrogram where the intensity corresponds to the signal energy at that given time and frequency, granting users a live view of the spectrum's fluctuations. 

![](imgs/gamutrf-gui.png)
*Waterfall GUI of GamutRF*

The final output of the data visualization process is wrapped in a Flask-based webpage which can auto configure based on the metadata provided with the FFT values from the ZMQ broker. All that is needed is to point the gamutrf-waterfall container to the gamutrf-scanner. This step can be done locally on the GamutRF system or on a remote computer such as a laptop or phone. GamutRF also provides a webform for configuring the parameters of a worker. These parameters include the frequency, bandwidth, and duration of recording. The webform offers a manual way to submit API requests to the worker, like tasking via sigfinder.   

## Data Transport  

Aside from the control APIs, GamutRF’s primary data transport between components is Java-Script Object Notation (JSON)5 over ZMQ6, with the scanner acting as a publisher, supporting potentially many clients such as user interface instances, or signal finders. This transport is unidirectional going from scanner to client and provides FFT, time, frequency, power, and scan metadata to include scanner configuration information such as frequency range, sample rate, and the current state of the scan. GamutRF includes a client library that implements this API and can be used by third party systems to receive GamutRF scanner data. The library supports aggregation, such that a client may attach to multiple scanners (which could have their own radios and may be scanning different ranges at different rates). 

## GNU radio 

GNU Radio7 was used throughout the course of development for this effort. GNU Radio is an open-source SDR framework used for developing prototypes and signal processing blocks. It supports a variety RF hardware like the radios previously mentioned to create software-defined radio-based systems, or without hardware to simulate or evaluate a waveform or signal flow. GNU Radio provides pre-defined signal processing blocks that have been thoroughly tested which can be used to build waveforms. It also lets you easily build custom blocks that can be integrated into a signal flow.  GNU Radio has a well-documented and supported API and has a large user-base with a lot of community support.  

### GNU Radio Out-Of-Tree Modules 

One advantage of using the GNU Radio framework is that is offers a great deal of flexibility if you need to extend GNU Radio with your own functions and blocks that are not in the main source tree. These custom blocks and functions are called Out-Of-Tree (OOT) modules8. We developed several OOT modules for this work and they are contained in gr-iqtlabs which is described in more detail below. 

Part of the GamutRF system consists of GNU radio software blocks written by IQT Labs, that have been made open source at http://github.com/iqtlabs/gr-iqtlabs. We intend to add more blocks over time as we continue to evolve GamutRF and our work in SDR generally. The repository also allows the wider community to benefit from our work by using the modules separately from GamutRF if need be.  

The blocks are divided into two main categories; blocks that directly provide GamutRF scanner functionality, chief among them the retune_fft, image_inference, and VkFFT blocks. These blocks provide the scan-and-retune sweep, production of spectrograms for ML inference, and CPU offload of FFT calculations respectively, all functions which are not provided by the core GNU radio framework. 

The other blocks provide supporting functionality. The block tuneable_test_source simulates a retuneable SDR device with predictable simulated simple data output so that the scanner code can be automatically tested with best practice continuous integration techniques. The write_freq_samples block implements compressed sample archiving using the zstandard9 compression algorithm. The vector_roll and vector_to_json blocks enable third party FFT output to be rearranged into a more convenient layout and allow GNU radio raw data to be represented as JSON for easier integration with third party software, respectively. 

## Data Compression 

Digital signal processing with SDR involves generating large volumes of data in producing, processing, and storing millions of I/Q samples per second. With frameworks such as GNU radio, the samples must be transformed into complex, 32-bit floating point numbers before further processing. As an example, data can be produced at rates of up to 0.75GB per  second in extreme cases. This data needs to be consumed, processed, and sometimes stored to disk. This presents storage capacity and I/O performance challenges on mobile platforms. For example, on the Raspberry Pi4, the USB3 controller hardware can struggle to handle very high incoming data rates from SDRs and outgoing data rates to USB3 hard disk simultaneously. Even when cloud storage is available and plentiful, network transfer speeds to and from cloud storage can be a bottleneck.  

We observed that many commonly available SDRs were based on similar ADC hardware, and that hardware has only 12-bit resolution, which lead to the insight that the raw data should be highly compressible since not all the full 32 bits of floating-point resolution are needed. We benchmarked several compression approaches and found that zstandard achieved 30-40% compression at very low CPU cost. zstandard is intended specifically to optimize CPU cost and performance. This serves to relieve USB3 bus contention between SDR and hard disks on the more resource constrained platforms such as the Raspberry Pi4. We implemented libraries that allow ML pipelines to read zstandard compressed data which saves cloud storage space.  

## Signal Strength  

Initially we used the received signal strength along with simple propagation models to estimate distance and track the signals we were interested in. The received signal strength (RSS) is a measurement of the power of a detected signal at the receiver. The RSS indicator or RSSI is a value or index that is proportional to the received power of the signal. There is generally no set standard range for RSSI, different equipment manufacturers define their own range scale. For example, Cisco uses 0-100, while Atheros uses 0-60 and others use 0-255. RSSI is usually measured at the front end of the radio as close to the antenna terminal as possible to get the optimal measurement of the received signal power.    

We take a moving average of this value to smooth it out as it can jump around quite a bit and we are most interested in the slower moving trend of the value. This helps to estimate distance from the target. Figure 7 below shows the portion of the GNU Radio flow graph that estimates the RSSI value. 

Birdseye (RF geolocalization tool) is also located on the IQT Labs Github at https://github.com/iqtlabs/birdseye. The repository contains instructions for using the Birdseye tool as well as different methodologies for ML-enabled localization. Birdseye can be used in conjunction with GamutRF or as a standalone tool. When using with the GamutRF system, the instructions for integration are in the Build.md file which detail how to run Birdseye as a systemd service. 
